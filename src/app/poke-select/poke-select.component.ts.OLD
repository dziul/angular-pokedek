import { CollectionViewer, DataSource } from '@angular/cdk/collections';
import {
  AfterViewInit,
  ChangeDetectionStrategy,
  Component,
  ElementRef,
  OnDestroy,
  OnInit,
  Output,
  ViewChild,
} from '@angular/core';

import { BehaviorSubject, fromEvent, Observable, Subject, Subscription } from 'rxjs';
import {
  bufferCount,
  concatAll,
  concatMap,
  delay,
  finalize,
  map,
  mergeAll,
  mergeMap,
  take,
  tap,
  toArray,
} from 'rxjs/operators';
import { initialize } from 'src/app/shared/operators/initialize.operator';

import { MainRegionWithId } from '../models/pokemon-generation.model';
import { PokemonParsedModel } from '../models/pokemon.model';
import { PokedekStoreService } from '../pokedek-store.service';
import { PokedekService } from '../pokedek.service';

/** @title Virtual scroll with a custom data source */
@Component({
  selector: 'app-poke-list',
  templateUrl: './poke-list.component.html',
  styleUrls: ['./poke-list.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PokeListComponent implements OnInit, AfterViewInit, OnDestroy {
  constructor(private store: PokedekStoreService) {}
  // @ViewChild('scrolling') listElement: ElementRef<HTMLDivElement>;
  // @Output() size = 20;

  // loading = false;
  // loading$ = new BehaviorSubject<boolean>(false);
  // chunklist: MainRegionWithId[][] = [];
  // chunklist$ = new BehaviorSubject<MainRegionWithId[][]>([]);
  // list: PokemonParsedModel[] = [];
  // list$ = new BehaviorSubject<PokemonParsedModel[]>([]);
  // listParsed$ = new BehaviorSubject<MainRegionWithId[]>([]);
  // subscriptionPokemonList$: Subscription;

  ngOnInit() {
    // this.subscriptionPokemonList$ = this.store
    //   .getPokemonList()
    //   .pipe()
    //   .pipe(mergeAll(), bufferCount(this.size), toArray())
    //   // me parece mais custoso do que o alternativa de baixo
    //   .subscribe((data) => {
    //     // let start = 0;
    //     // let end = this.size;
    //     // let count = data.length;
    //     // while (count > 0) {
    //     //   this.list.push(data.slice(start, end));
    //     //   start += this.size;
    //     //   end += this.size;
    //     //   count -= this.size;
    //     // }
    //     this.chunklist = data;
    //     this.listParsed$.next(this.chunklist.shift());
    //   });
    // this.loading$.next(true);
    // this.listParsed$
    //   .pipe(
    //     concatAll(),
    //     concatMap((data) => this.store.getPokemonInformation(data.name))
    //   )
    //   .subscribe((item) => {
    //     this.list.push(item);
    //     this.list$.next(this.list);
    //     this.loading$.next(false);
    //   });
    // this.loading$.subscribe((loading) => {
    //   console.log(loading);
    //   this.loading = loading;
    // });
  }

  ngAfterViewInit() {
    // fromEvent<Event & { target: HTMLDivElement }>(
    //   this.listElement.nativeElement,
    //   'scroll'
    // ).subscribe((event) => {
    //   const { target } = event;
    //   const heightParsed = target.scrollHeight - target.clientHeight;
    //   const scrollTop = heightParsed - target.scrollTop;
    //   const scrollTopPercentage = Math.floor((scrollTop / heightParsed) * 100);
    //   if (scrollTopPercentage < 1 && !this.loading && this.chunklist.length) {
    //     this.loading$.next(true);
    //     this.listParsed$.next(this.chunklist.shift());
    //   }
    // });
  }

  ngOnDestroy() {
    // this.subscriptionPokemonList$.unsubscribe();
    // this.listParsed$.unsubscribe();
  }
}
